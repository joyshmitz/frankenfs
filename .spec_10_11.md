## 10. Filesystem Operations Pipeline

### 10.1 Mount Sequence

Each phase MUST complete before the next; failure is fatal.

1. **Open device** (`ffs-block`): `O_RDWR` (or `O_RDONLY` if `--ro`). Validate alignment to 512.
2. **Read superblock** (`ffs-ondisk`): 1024 bytes at offset 1024. Verify magic `0xEF53`. Compute `block_size = 1024 << s_log_block_size`.
3. **Validate features** (`ffs-ext4`): Parse compat/incompat/ro_compat flags. Reject unsupported INCOMPAT. Read-only if unknown RO_COMPAT.
4. **Read group descriptors** (`ffs-ondisk`): `ceil(blocks_count/blocks_per_group)` descriptors, 32 or 64 bytes. Verify checksums.
5. **Init ARC cache** (`ffs-block`): Four-list ARC (T1/T2/B1/B2). Default: `min(RAM/4, 256MB)`. Pre-warm SB + GDT + root inode.
6. **Replay JBD2** (`ffs-journal`): If `COMPAT_HAS_JOURNAL` and dirty (`s_start != 0`): scan, apply, revoke, mark clean. See 11.6.
7. **Init MVCC** (`ffs-mvcc`): `CommitSeq(1)`, `TxnId(1)`. Native `--mvcc`: per-block version chains. JBD2-compat: single-writer mutex.
8. **Init repair** (`ffs-repair`): Scan per-group reserved blocks for RaptorQ metadata. Mark missing groups for re-encoding.
9. **Background tasks** (`ffs-core`): Three `Region`-scoped: Scrub (1 pass/hr), GC (30s), Flush (5s or 25% dirty).
10. **Register FUSE** (`ffs-fuse`): `fuser::Session` with `AutoUnmount`, `DefaultPermissions`. `max_write=128KiB`. Enter event loop.

**Unmount:** destroy() -> cancel Regions -> flush ARC -> MVCC: final GC / JBD2: checkpoint -> update superblock (s_mnt_count++, s_wtime) -> sync + close.

### 10.2 Read Path

MUST be lock-free for readers, allocation-free on cache hit, bounded latency.

```
FUSE read(ino, offset, size)
  --> ffs-fuse: validate, translate ino
  --> ffs-mvcc: begin_read_txn() -> Snapshot { high: current_commit_seq }
  --> ffs-inode: resolve_inode(ino, snapshot)
        ARC lookup for inode table block, parse Ext4Inode, permission check
  --> ffs-extent: map_logical_to_physical(inode, offset, size)
        Walk extent B+tree (depth 0: binary search leaves; depth>0: descend)
        Return [(phys_block, offset_in_block, bytes)]; holes -> zeroes
  --> ffs-block: read_blocks(phys_blocks, snapshot)
        Per block: ARC probe -> HIT: return ref; MISS: pread64 via blocking_pool,
        verify checksum (CRC32C/BLAKE3), on fail: RaptorQ recover, insert ARC T1
        MVCC mode: resolve version chain per snapshot
  --> ffs-fuse: assemble, truncate to min(size, file_size - offset), return to FUSE
```

| Property | Requirement |
|----------|------------|
| Lock contention | Zero (snapshot is a `CommitSeq` copy) |
| Allocations (cache hit) | Zero (ref to ARC block) |
| Extent tree descent | O(depth) reads; depth 0-2 typical |
| Prefetch | If extent spans consecutive blocks, readahead next N |

**atime:** `relatime` default (update only if `atime < mtime/ctime` or >24h old). `noatime`: skip. `strictatime`: write txn per read.

### 10.3 Write Path

Every write MUST be in an MVCC transaction with COW semantics (native mode).

```
FUSE write(ino, offset, data)
  --> ffs-fuse: validate, translate ino
  --> ffs-mvcc: begin_write_txn() -> Transaction { id, snapshot }
        JBD2-compat: acquire global write mutex first
  --> ffs-inode: resolve_inode(ino, snapshot), check write permission
  --> ffs-extent: map_logical_to_physical(inode, offset, len)
  --> ffs-alloc: allocate_blocks(needed) [if new blocks needed]
        mballoc: prealloc -> goal -> best-fit. Update bitmap + group desc.
  --> ffs-mvcc + ffs-block: write_blocks_cow(blocks, data)
        MVCC: new phys location, BlockVersion(committed=false). JBD2: in-place.
        Compute checksum. Dirty in ARC. Track in write set.
  --> ffs-btree: update_extent_tree() [if new extents; split on overflow, COW]
  --> ffs-inode: update i_size/i_mtime/i_ctime/i_blocks
  --> ffs-mvcc: commit_transaction()
        FCW: latest_commit > snapshot.high -> ABORT
        SSI: incoming+outgoing rw-antidep -> ABORT
        Assign CommitSeq, set committed=true, publish to chain heads
  --> ffs-repair: mark_groups_stale(affected groups)
  --> Return bytes_written
```

**Abort/retry:** Discard versions, return blocks. Retry 3x (backoff: 0, 100us, 1ms). `EAGAIN` on exhaustion.

**fsync:** Flush dirty ARC pages for inode to disk. `fdatasync()/fsync()`. `--eager-repair`: blocking RaptorQ re-encode.

### 10.4 Directory Operations

All wrapped in write transactions. Htree index updated for large directories.

**create(parent, name, mode):** Write txn -> `allocate_inode()` (Orlov: same group as parent) -> `initialize_inode()` (mode, timestamps, empty extent header: `eh_magic=0xF30A, entries=0, max=4, depth=0`) -> `add_directory_entry()` (linear: gap/append; htree: hash, insert, split) -> update parent mtime/ctime -> commit.

**mkdir:** Like create + `S_IFDIR` mode, `links_count=2`, parent `links++`, init `.`/`..`, alloc one data block.

**unlink:** Write txn -> lookup -> verify not dir -> remove entry (inode=0, merge rec_len) -> decrement links (if 0: free blocks + inode) -> commit.

**rmdir:** Like unlink + verify empty, decrement parent links. `ENOTEMPTY` if non-empty.

**rename:** Write txn -> lookup old -> if new exists: validate types, remove -> remove old, add new -> if dir: update `..`, adjust links -> commit. `RENAME_NOREPLACE`: `EEXIST`. `RENAME_EXCHANGE`: atomic swap.

### 10.5 Metadata Operations

**getattr:** Read txn. Resolve inode. Map to `fuser::FileAttr`.

**setattr:** Write txn. Apply mode/uid/gid/size/atime/mtime. Truncate: free blocks. Always update ctime. Commit.

**statfs:** No txn. Cached superblock: bsize, blocks, bfree, bavail=free-reserved, files, ffree, namemax=255.

### 10.6 Symlink, Readlink, Link

**symlink:** Write txn. Alloc inode. If `target.len() <= 60`: store in `i_block[]` (fast symlink). Else: alloc data block + extent. Add dir entry. Commit.

**readlink:** Read txn. If `i_blocks==0 && i_size<=60`: read `i_block[]`. Else: extent tree.

**link:** Write txn. Verify not dir. Increment `links_count`, update `ctime`. Add dir entry. Commit.

### 10.7 Error Mapping

| FfsError | errno | Condition |
|----------|-------|-----------|
| `NotFound` | `ENOENT` | Inode/entry missing |
| `PermissionDenied` | `EACCES` | Insufficient permission |
| `AlreadyExists` | `EEXIST` | Entry exists (O_EXCL) |
| `NotDirectory` | `ENOTDIR` | Expected dir |
| `IsDirectory` | `EISDIR` | File op on dir |
| `DirectoryNotEmpty` | `ENOTEMPTY` | rmdir non-empty |
| `NoSpace` | `ENOSPC` | Allocation failed |
| `ReadOnly` | `EROFS` | Write on ro mount |
| `NameTooLong` | `ENAMETOOLONG` | Name > 255 bytes |
| `TooManyLinks` | `EMLINK` | links > 65000 |
| `MvccConflict` | `EAGAIN` | FCW conflict (retries exhausted) |
| `SsiConflict` | `EAGAIN` | SSI abort |
| `Corruption` | `EIO` | Checksum mismatch |
| `IoError` | `EIO` | Device I/O error |

---

## 11. On-Disk Format Compatibility

All multi-byte fields are **little-endian**. Offsets relative to structure start unless noted.

### 11.1 ext4 Superblock

Byte offset 1024, length 1024 bytes. Fixed regardless of block size.

#### 11.1.1 Field Table

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x000` | 4 | `s_inodes_count` | Total inode count |
| `0x004` | 4 | `s_blocks_count_lo` | Total blocks (low 32) |
| `0x008` | 4 | `s_r_blocks_count_lo` | Reserved blocks (low 32) |
| `0x00C` | 4 | `s_free_blocks_count_lo` | Free blocks (low 32) |
| `0x010` | 4 | `s_free_inodes_count` | Free inodes |
| `0x014` | 4 | `s_first_data_block` | First data block (0 for 4K, 1 for 1K) |
| `0x018` | 4 | `s_log_block_size` | Block size = `1024 << value` |
| `0x01C` | 4 | `s_log_cluster_size` | Cluster size (bigalloc) |
| `0x020` | 4 | `s_blocks_per_group` | Blocks per group |
| `0x024` | 4 | `s_clusters_per_group` | Clusters per group |
| `0x028` | 4 | `s_inodes_per_group` | Inodes per group |
| `0x02C` | 4 | `s_mtime` | Last mount time |
| `0x030` | 4 | `s_wtime` | Last write time |
| `0x034` | 2 | `s_mnt_count` | Mount count since fsck |
| `0x036` | 2 | `s_max_mnt_count` | Max mounts before fsck |
| `0x038` | 2 | `s_magic` | **`0xEF53`** |
| `0x03A` | 2 | `s_state` | 1=clean, 2=errors, 4=orphans |
| `0x03C` | 2 | `s_errors` | 1=continue, 2=ro, 3=panic |
| `0x03E` | 2 | `s_minor_rev_level` | Minor revision |
| `0x040` | 4 | `s_lastcheck` | Last fsck time |
| `0x044` | 4 | `s_checkinterval` | Max time between fscks |
| `0x048` | 4 | `s_creator_os` | Creator OS (0=Linux) |
| `0x04C` | 4 | `s_rev_level` | 0=original, 1=dynamic |
| `0x050` | 2 | `s_def_resuid` | Default reserved UID |
| `0x052` | 2 | `s_def_resgid` | Default reserved GID |
| `0x054` | 4 | `s_first_ino` | First non-reserved inode (typically 11) |
| `0x058` | 2 | `s_inode_size` | Inode size (128 or 256) |
| `0x05A` | 2 | `s_block_group_nr` | Block group of this SB copy |
| `0x05C` | 4 | `s_feature_compat` | Compatible features |
| `0x060` | 4 | `s_feature_incompat` | Incompatible features |
| `0x064` | 4 | `s_feature_ro_compat` | Read-only compatible features |
| `0x068` | 16 | `s_uuid` | 128-bit UUID |
| `0x078` | 16 | `s_volume_name` | Volume label (NUL-padded) |
| `0x088` | 64 | `s_last_mounted` | Last mount path |
| `0x0C8`-`0x0CD` | 6 | `s_algorithm_usage_bitmap`, `s_prealloc_*` | Compression (unused), file/dir prealloc |
| `0x0CE` | 2 | `s_reserved_gdt_blocks` | Reserved GDT blocks |
| `0x0D0` | 16 | `s_journal_uuid` | Journal UUID |
| `0x0E0` | 4 | `s_journal_inum` | Journal inode (typically 8) |
| `0x0E4` | 4 | `s_journal_dev` | Journal device (0=internal) |
| `0x0E8` | 4 | `s_last_orphan` | Head of orphan list |
| `0x0EC` | 16 | `s_hash_seed` | htree hash seed (4 x u32) |
| `0x0FC` | 1 | `s_def_hash_version` | 0=legacy, 1=half_md4, 2=tea, 3-5=unsigned |
| `0x0FE` | 2 | `s_desc_size` | Group desc size (32 or 64) |
| `0x100` | 4 | `s_default_mount_opts` | Default mount options |
| `0x104` | 4 | `s_first_meta_bg` | First meta block group |
| `0x108` | 4 | `s_mkfs_time` | Creation time |
| `0x10C` | 68 | `s_jnl_blocks` | Journal inode backup (17 x u32) |
| `0x150` | 4 | `s_blocks_count_hi` | Total blocks (high 32; `INCOMPAT_64BIT`) |
| `0x154` | 4 | `s_r_blocks_count_hi` | Reserved blocks (high 32) |
| `0x158` | 4 | `s_free_blocks_count_hi` | Free blocks (high 32) |
| `0x15C` | 2+2 | `s_min_extra_isize`, `s_want_extra_isize` | Min/desired extra inode size |
| `0x160` | 4 | `s_flags` | Misc flags |
| `0x164`-`0x16F` | 12 | `s_raid_stride`, `s_mmp_*` | RAID stride, MMP interval + block |
| `0x170` | 4 | `s_raid_stripe_width` | RAID stripe width |
| `0x174` | 1 | `s_log_groups_per_flex` | Flex group size = `2^value` |
| `0x175` | 1 | `s_checksum_type` | 1=crc32c |
| `0x178` | 8 | `s_kbytes_written` | Lifetime KB written |
| `0x180`-`0x193` | 20 | `s_snapshot_*` | Snapshot inode, ID, reserved blocks, list head |
| `0x194` | 4 | `s_error_count` | Error count |
| `0x198`-`0x1FF` | 104 | `s_first_error_*`, `s_last_error_*` | Error tracking: time, inode, block, func, line |
| `0x200` | 64 | `s_mount_opts` | Mount options string |
| `0x240` | 4 | `s_usr_quota_inum` | User quota inode |
| `0x244` | 4 | `s_grp_quota_inum` | Group quota inode |
| `0x248` | 4 | `s_overhead_blocks` | Overhead blocks |
| `0x24C` | 8 | `s_backup_bgs` | Backup SB groups (sparse_super2) |
| `0x254`-`0x267` | 20 | `s_encrypt_*` | Encryption algorithms + salt |
| `0x268` | 4 | `s_lpf_ino` | lost+found inode |
| `0x26C` | 4 | `s_prj_quota_inum` | Project quota inode |
| `0x270` | 4 | `s_checksum_seed` | CRC32C seed (CRC32C of UUID if `INCOMPAT_CSUM_SEED`) |
| `0x274`-`0x27B` | 8 | `s_*_hi`, pad | High 8 bits of timestamps + padding |
| `0x27C` | 4 | `s_encoding` | Filename encoding (casefold) |
| `0x280` | 4 | `s_encoding_flags`/`s_orphan_file_inum` | Encoding flags (2) + orphan inode (2) |
| `0x284` | 376 | `s_reserved` | Zero-filled |
| `0x3FC` | 4 | `s_checksum` | Superblock CRC32C |

**Total: 1024 bytes (0x400).** Checksum: CRC32C of `0x000..0x3FB` with `s_checksum_seed` as initial value (zero `s_checksum` first).

**Backups:** First block of groups that are powers of 3, 5, or 7 when `SPARSE_SUPER` enabled.

#### 11.1.2 Block Size

`block_size = 1024 << s_log_block_size`. Supported: 0 (1K) through 6 (64K). Default: 2 (4K).

#### 11.1.3 Feature Flags

**Incompatible (`s_feature_incompat` at `0x60`) -- unknown = mount MUST fail:**

REQUIRED: `FILETYPE`(0x0002), `EXTENTS`(0x0040).
Supported: `RECOVER`(0x0004), `META_BG`(0x0010), `64BIT`(0x0080), `FLEX_BG`(0x0200), `EA_INODE`(0x0400), `CSUM_SEED`(0x2000), `LARGEDIR`(0x4000).
Ignored: `MMP`(0x0100, warn), `DIRDATA`(0x1000).
REJECTED: `COMPRESSION`(0x0001), `JOURNAL_DEV`(0x0008), `INLINE_DATA`(0x8000), `ENCRYPT`(0x10000), `CASEFOLD`(0x20000).

**Compatible (`s_feature_compat` at `0x5C`) -- advisory:**

Supported: `HAS_JOURNAL`(0x0004), `EXT_ATTR`(0x0008), `DIR_INDEX`(0x0020), `SPARSE_SUPER2`(0x0200), `ORPHAN_FILE`(0x1000).

**Read-only compatible (`s_feature_ro_compat` at `0x64`) -- unknown = mount read-only:**

Supported: `SPARSE_SUPER`(0x0001), `LARGE_FILE`(0x0002), `HUGE_FILE`(0x0008), `GDT_CSUM`(0x0010), `DIR_NLINK`(0x0020), `EXTRA_ISIZE`(0x0040), `METADATA_CSUM`(0x0400), `READONLY`(0x1000), `ORPHAN_PRESENT`(0x8000).

#### 11.1.4 64-bit Mode

If `INCOMPAT_64BIT`: `s_desc_size >= 64`, block counts combine lo|hi<<32, 64-byte descriptors. Otherwise: 32-byte, 32-bit counts, max 16 TB at 4K.

### 11.2 Group Descriptors

Block after superblock. Count = `ceil(blocks_count / blocks_per_group)`.

#### 11.2.1 Standard (32 bytes)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 4 | `bg_block_bitmap_lo` | Block bitmap block |
| `0x04` | 4 | `bg_inode_bitmap_lo` | Inode bitmap block |
| `0x08` | 4 | `bg_inode_table_lo` | Inode table start |
| `0x0C` | 2 | `bg_free_blocks_count_lo` | Free blocks |
| `0x0E` | 2 | `bg_free_inodes_count_lo` | Free inodes |
| `0x10` | 2 | `bg_used_dirs_count_lo` | Directory count |
| `0x12` | 2 | `bg_flags` | `INODE_UNINIT`(0x1), `BLOCK_UNINIT`(0x2), `INODE_ZEROED`(0x4) |
| `0x14` | 4 | `bg_exclude_bitmap_lo` | Exclude bitmap |
| `0x18` | 2 | `bg_block_bitmap_csum_lo` | Block bitmap checksum |
| `0x1A` | 2 | `bg_inode_bitmap_csum_lo` | Inode bitmap checksum |
| `0x1C` | 2 | `bg_itable_unused_lo` | Unused inodes |
| `0x1E` | 2 | `bg_checksum` | Descriptor checksum |

#### 11.2.2 Extended (64 bytes, `INCOMPAT_64BIT`)

Bytes 0x00-0x1F same as standard. At 0x20: `bg_block_bitmap_hi`(4), `bg_inode_bitmap_hi`(4), `bg_inode_table_hi`(4), `bg_free_blocks_count_hi`(2), `bg_free_inodes_count_hi`(2), `bg_used_dirs_count_hi`(2), `bg_itable_unused_hi`(2), `bg_exclude_bitmap_hi`(4), `bg_block_bitmap_csum_hi`(2), `bg_inode_bitmap_csum_hi`(2), reserved(4).

#### 11.2.3 Checksum

**CRC16** (if `GDT_CSUM`, not `METADATA_CSUM`): `crc16(~0, s_uuid || group_nr(le32) || desc_with_checksum_zeroed)`.

**CRC32C** (if `METADATA_CSUM`): `bg_checksum = lower16(crc32c(s_checksum_seed, group_nr(le32) || desc_up_to_checksum))`.

### 11.3 Inode Format

Size = `s_inode_size` (128 min, 256 typical). Per block = `block_size / s_inode_size` (16 typical).

**Location:** `group = (ino-1) / inodes_per_group`, `index = (ino-1) % inodes_per_group`, `block = bg_inode_table[group] + (index * inode_size) / block_size`, `off = (index * inode_size) % block_size`.

#### 11.3.1 Core Fields (128 bytes)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 2 | `i_mode` | Type (upper 4: 0x4=dir, 0x8=reg, 0xA=symlink) + perms (lower 12) |
| `0x02` | 2 | `i_uid` | Owner UID (low 16) |
| `0x04` | 4 | `i_size_lo` | Size (low 32) |
| `0x08` | 4 | `i_atime` | Access time (seconds) |
| `0x0C` | 4 | `i_ctime` | Change time (seconds) |
| `0x10` | 4 | `i_mtime` | Modification time (seconds) |
| `0x14` | 4 | `i_dtime` | Deletion time |
| `0x18` | 2 | `i_gid` | Group GID (low 16) |
| `0x1A` | 2 | `i_links_count` | Hard link count |
| `0x1C` | 4 | `i_blocks_lo` | Blocks (512B sectors; fs-blocks if HUGE_FILE) |
| `0x20` | 4 | `i_flags` | Inode flags |
| `0x24` | 4 | `i_osd1` | Linux: `l_i_version` |
| `0x28` | 60 | `i_block[15]` | Extent tree root (see 11.4) |
| `0x64` | 4 | `i_generation` | File version (NFS) |
| `0x68` | 4 | `i_file_acl_lo` | Xattr block (low 32) |
| `0x6C` | 4 | `i_size_high` | Size (high 32) |
| `0x70` | 4 | `i_obso_faddr` | Obsolete |
| `0x74` | 2 | `l_i_blocks_high` | Blocks (high 16) |
| `0x76` | 2 | `l_i_file_acl_high` | Xattr block (high 16) |
| `0x78` | 2 | `l_i_uid_high` | UID (high 16) |
| `0x7A` | 2 | `l_i_gid_high` | GID (high 16) |
| `0x7C` | 2 | `l_i_checksum_lo` | Inode checksum (low 16) |
| `0x7E` | 2 | Reserved | |

#### 11.3.2 Extended Fields (0x80+, if `s_inode_size > 128`)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x80` | 2 | `i_extra_isize` | Extra fields size |
| `0x82` | 2 | `i_checksum_hi` | Inode checksum (high 16) |
| `0x84` | 4 | `i_ctime_extra` | bits 0-1: epoch extension, bits 2-31: nanoseconds |
| `0x88` | 4 | `i_mtime_extra` | Same format |
| `0x8C` | 4 | `i_atime_extra` | Same format |
| `0x90` | 4 | `i_crtime` | Creation time (seconds) |
| `0x94` | 4 | `i_crtime_extra` | Creation time extra |
| `0x98` | 4 | `i_version_hi` | Version (high 32) |
| `0x9C` | 4 | `i_projid` | Project ID |

**Timestamp format:** `seconds = i_xtime | (epoch_bits << 32)` (34-bit, 1901-2446). `nanoseconds = bits[2..31]`.

#### 11.3.3 Key Inode Flags

| Flag | Value | Meaning |
|------|-------|---------|
| `SYNC_FL` | `0x00000008` | Synchronous updates |
| `IMMUTABLE_FL` | `0x00000010` | Immutable |
| `APPEND_FL` | `0x00000020` | Append-only |
| `NOATIME_FL` | `0x00000080` | No atime |
| `EXTENTS_FL` | `0x00080000` | Uses extents (MUST be set) |
| `HUGE_FILE_FL` | `0x00040000` | Blocks in fs-block units |
| `EA_INODE_FL` | `0x00200000` | Large xattr in inode |
| `INLINE_DATA_FL` | `0x10000000` | Inline data (rejected) |

#### 11.3.4 Inode Checksum (`METADATA_CSUM`)

```
crc = crc32c(s_checksum_seed, ino(le32) || generation(le32) || inode_bytes_with_csum_zeroed)
l_i_checksum_lo = low16(crc)    // offset 0x7C
i_checksum_hi   = high16(crc)   // offset 0x82 (if inode_size > 128)
```

### 11.4 Extent Tree

B+tree: logical-to-physical block mapping. Root in `i_block[15]` (60 bytes). External nodes in allocated blocks.

#### 11.4.1 Header (12 bytes, every node)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 2 | `eh_magic` | **`0xF30A`** |
| `0x02` | 2 | `eh_entries` | Valid entry count |
| `0x04` | 2 | `eh_max` | Root=4 (48/12), external=`(block_size-16)/12` (340 for 4K) |
| `0x06` | 2 | `eh_depth` | 0=leaf, >0=internal |
| `0x08` | 4 | `eh_generation` | Tree version |

#### 11.4.2 Leaf Entry (`ext4_extent`, 12 bytes, depth==0)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 4 | `ee_block` | First logical block |
| `0x04` | 2 | `ee_len` | Length. Bit 15 = unwritten. Actual = `ee_len & 0x7FFF`. Max 32768. |
| `0x06` | 2 | `ee_start_hi` | Physical block (high 16) |
| `0x08` | 4 | `ee_start_lo` | Physical block (low 32) |

Physical: `ee_start_lo | (ee_start_hi << 32)` (48-bit).

#### 11.4.3 Index Entry (`ext4_extent_idx`, 12 bytes, depth>0)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 4 | `ei_block` | Logical block of subtree |
| `0x04` | 4 | `ei_leaf_lo` | Child block (low 32) |
| `0x08` | 2 | `ei_leaf_hi` | Child block (high 16) |
| `0x0A` | 2 | Reserved | |

**Traversal:** Binary search for largest `ei_block <= target` at each level. Leaf: binary search extents. Unmapped = hole (zeroes).

#### 11.4.4 Tail Checksum (external nodes, `METADATA_CSUM`)

4 bytes at `block_end - 4`: `crc32c(s_checksum_seed, ino(le32) || generation(le32) || block_excl_tail)`.

### 11.5 Directory Entries

Directories are files whose data blocks contain variable-length entries.

#### 11.5.1 `ext4_dir_entry_2`

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x00` | 4 | `inode` | Target inode (0 = deleted) |
| `0x04` | 2 | `rec_len` | Entry size (4-byte aligned, min 12). Last extends to block end. |
| `0x06` | 1 | `name_len` | Name length |
| `0x07` | 1 | `file_type` | 1=reg, 2=dir, 3=chrdev, 4=blkdev, 5=fifo, 6=sock, 7=symlink |
| `0x08` | N | `name` | Filename (NOT NUL-terminated) |

**Checksum tail** (`METADATA_CSUM`): Last 12 bytes: `{ 0(4), rec_len=12(2), 0(1), 0xDE(1), crc32c(4) }`. CRC: `crc32c(seed, ino || generation || block_excl_tail)`.

#### 11.5.2 Htree Index (`COMPAT_DIR_INDEX`)

First dir block = `dx_root`: `.` entry (12B) + `..` entry (12B) + `dx_root_info` at 0x18 (reserved(4), hash_version(1), info_len=8(1), indirect_levels(1), unused(1)) + `dx_root` at 0x20 (limit(2), count(2), block(4)) + `dx_entry[]` at 0x28 (hash(4) + block(4) each).

**Lookup:** `dx_hash(name)` with `s_def_hash_version` + `s_hash_seed` -> binary search dx_entries -> read leaf -> linear scan.

**Hash algorithms:** HALF_MD4 (v1/4): MD4 compression in 32B chunks, 3 rounds. TEA (v2/5): 16B chunks, 16 rounds, delta `0x9E3779B9`. Both return `(major & ~1, minor)`. Unsigned variants (3/4/5): bytes as `u8`. Signed (0/1/2): `i8` sign-extended.

### 11.6 JBD2 Journal

Internal file at `s_journal_inum` (typically inode 8). Circular log of block-level transactions.

#### 11.6.1 Journal Superblock (block 0)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| `0x000` | 4 | `h_magic` | **`0xC03B3998`** |
| `0x004` | 4 | `h_blocktype` | 3=SB v1, 4=SB v2 |
| `0x008` | 4 | `h_sequence` | First valid txn seq |
| `0x00C` | 4 | `s_blocksize` | Journal block size (= fs block size) |
| `0x010` | 4 | `s_maxlen` | Total journal blocks |
| `0x014` | 4 | `s_first` | First usable block |
| `0x018` | 4 | `s_sequence` | Seq of first uncommitted txn |
| `0x01C` | 4 | `s_start` | Block of first uncommitted txn (**0 = clean**) |
| `0x020` | 4 | `s_errno` | FS error code |
| `0x028` | 4 | `s_feature_incompat` | bit0=revoke, bit1=64bit, bit2=async, bit4=csum_v2, bit5=csum_v3 |
| `0x030` | 16 | `s_uuid` | Journal UUID |
| `0x050` | 1 | `s_checksum_type` | 1=CRC32C |
| `0x0FC` | 4 | `s_checksum` | SB CRC32C |

#### 11.6.2 Block Types

All start with 12-byte header: `{ h_magic: 0xC03B3998, h_blocktype, h_sequence }`.

| Type | Value | Purpose |
|------|-------|---------|
| `DESCRIPTOR` | 1 | Lists target blocks for following data |
| `COMMIT` | 2 | Transaction complete |
| `SB_V1`/`V2` | 3/4 | Journal superblock |
| `REVOKE` | 5 | Blocks to skip in replay |

#### 11.6.3 Descriptor Tag (v3, `CSUM_V3`)

| Offset | Size | Field |
|--------|------|-------|
| `0x00` | 4 | `t_blocknr` (low 32) |
| `0x04` | 4 | `t_flags`: bit0=ESCAPE, bit1=SAME_UUID, bit2=DELETED, bit3=LAST_TAG |
| `0x08` | 4 | `t_blocknr_high` (high 32) |
| `0x0C` | 4 | `t_checksum` (CRC32C of data block) |

16 bytes/tag. If `!SAME_UUID`: 16-byte UUID follows.

#### 11.6.4 Replay Algorithm

1. **SCAN:** From `s_start`, seq=`s_sequence`. Match magic+seq. Parse DESCRIPTOR/COMMIT/REVOKE. Stop on mismatch.
2. **REVOKE:** Build `(block_nr, txn_seq)` set.
3. **REPLAY:** Oldest first: skip if later revoked. Write data to target. ESCAPE flag: restore `0xC03B3998` at offset 0.
4. **CLEANUP:** `s_start=0`, write journal superblock.

Circular: `next(pos) = s_first + ((pos - s_first + 1) % (s_maxlen - s_first))`.

### 11.7 Bitmaps

**Block bitmap:** 1 block/group. Bit per block. Set = allocated. `(bitmap[idx/8] >> (idx%8)) & 1`.

**Inode bitmap:** 1 block/group. Bit per inode. Set = allocated.

**Checksum** (`METADATA_CSUM`): `crc32c(s_checksum_seed, bitmap_data)`. Low 16 in `bg_*_csum_lo`, high 16 in `bg_*_csum_hi` (64-bit only).

### 11.8 Special Inodes

| Inode | Purpose |
|-------|---------|
| 0 | Invalid |
| 1 | Bad blocks |
| 2 | **Root directory** |
| 3-4 | User/group quota |
| 5 | Boot loader |
| 6 | Undelete directory |
| 7 | Reserved GDT |
| 8 | **Journal** |
| 9-10 | Exclude/replica |
| 11+ | First user inode (`s_first_ino`) |

### 11.9 Layout

```
+--------+-----------+-----+--------+--------+--------+--------+
|Boot pad| Superblock| GDT | Blk bm | Ino bm | Ino tbl| Data   |
|1024 B  | 1024 B    |N blk| 1 blk  | 1 blk  | M blks |rest    |
+--------+-----------+-----+--------+--------+--------+--------+
|<--------------------- Block Group 0 ----------------------->|
```

4K blocks, 32768 blks/group: inode table ~512 blocks, data ~31744 blocks (~124 MB/group).
